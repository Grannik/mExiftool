#!/bin/bash
 E='echo -e';e='echo -en';trap "R;exit" 2
 ESC=$( $e "\e")
 TPUT(){ $e "\e[${1};${2}H" ;}
 CLEAR(){ $e "\ec";}
# 25 возможно это
 CIVIS(){ $e "\e[?25l";}
# это цвет текста списка перед курсором при значении 0 в переменной  UNMARK(){ $e "\e[0m";}
 MARK(){ $e "\e[1;90m";}
# 0 это цвет заднего фона списка
 UNMARK(){ $e "\e[0m";}
# ~~~~~~~~ Эти строки задают цвет фона ~~~~~~~~
 R(){ CLEAR ;stty sane;CLEAR;};
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 HEAD(){ for (( a=2; a<=41; a++ ))
  do
   TPUT $a 1
 $E "\033[34m\xE2\x94\x82                                                                                                                               \xE2\x94\x82\033[0m";
  done
 TPUT 6 3
 $E "\033[1;2mОперации с тегами                                     \033[36mTag operations\033[0m";
 TPUT 10 3
 $E "\033[36m#\033[0m";
 TPUT 39 4
 $E "\033[32mUp \xE2\x86\x91 \xE2\x86\x93 Down Select Enter\033[0m";
 MARK;TPUT 1 1
 $E "\033[0m\033[34m+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\033[0m" ;UNMARK;}
  i=0; CLEAR; CIVIS;NULL=/dev/null
 FOOT(){ MARK;TPUT 42 1
 $E "\033[0m\033[34m+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\033[0m";UNMARK;}
# это управляет кнопками ввер/хвниз
 i=0; CLEAR; CIVIS;NULL=/dev/null
#
 ARROW(){ IFS= read -s -n1 key 2>/dev/null >&2
           if [[ $key = $ESC ]];then
              read -s -n1 key 2>/dev/null >&2;
              if [[ $key = \[ ]]; then
                 read -s -n1 key 2>/dev/null >&2;
                 if [[ $key = A ]]; then echo up;fi
                 if [[ $key = B ]];then echo dn;fi
              fi
           fi
           if [[ "$key" == "$($e \\x0A)" ]];then echo enter;fi;}
  M0(){ TPUT  2 3; $e "Извлечь информацию для указанного тега                                     \033[32m -TAG                                            \033[0m";}
  M1(){ TPUT  3 3; $e "Исключить указанный тег из извлеченной информации                          \033[32m --TAG                                           \033[0m";}
  M2(){ TPUT  4 3; $e "Напишите новое значение для указанного тега                                \033[32m -TAG[+-^]=[VALUE]                               \033[0m";}
  M3(){ TPUT  5 3; $e "Примечания:                                                                \033[32m Notes:                                          \033[0m";}
  M4(){ TPUT  6 3; $e "Установите значение тега из содержимого файла DATFILE                      \033[32m -TAG<=DATFILE or -TAG<=FMT                      \033[0m";}
  M5(){ TPUT  7 3; $e "Скопируйте значения тегов из SRCFILE в FILE                                \033[32m -tagsFromFile SRCFILE or FMT                    \033[0m";}
  M6(){ TPUT  8 3; $e "Примечания:                                                                \033[32m Notes:                                          \033[0m";}
  M7(){ TPUT  9 3; $e "Исключить указанный тег                                                    \033[32m -x TAG (-exclude)                               \033[0m";}
  M8(){ TPUT 10 3; $e "Вывести информацию в виде аргументов exiftool                              \033[32m -args (-argFormat)                              \033[0m";}
  M9(){ TPUT 11 3; $e "Вывести запрошенные метаданные в двоичном формате без имен и описаний тегов\033[32m -b (-binary)                                    \033[0m";}
 M10(){ TPUT 12 3; $e "Установите формат печати для координат GPS                                 \033[32m -c FMT (-coordFormat)                           \033[0m";}
 M11(){ TPUT 13 3; $e "Если TYPE - «ExifTool» или не указан                                       \033[32m -charset [[TYPE=]CHARSET]                       \033[0m";}
 M12(){ TPUT 14 3; $e "ТИП Описание По умолчанию                                                                                                   ";}
 M13(){ TPUT 15 3; $e "Экспорт информации в формате CSV или импорт информации, если указан CSVFILE\033[32m -csv[[+]=CSVFILE]                               \033[0m";}
 M14(){ TPUT 16 3; $e "Установите формат значений тегов даты / времени                            \033[32m -d FMT (-dateFormat)                            \033[0m";}
 M15(){ TPUT 17 3; $e "Показывать идентификационный номер тега в десятичном формате               \033[32m -D (-decimal)                                   \033[0m";}
 M16(){ TPUT 18 3; $e "Экранирующие символы выходных тегов для HTML (-E), XML (-ex), C (-ec)      \033[32m -E, -ex, -ec (-escapeHTML, -escapeXML, -escapeC)\033[0m";}
 M17(){ TPUT 19 3; $e "Принудительная печать тегов, даже если их значения не найдены              \033[32m -f (-forcePrint)                                \033[0m";}
 M18(){ TPUT 20 3; $e "Организуйте вывод по группам тегов                                         \033[32m -g[NUM][:NUM...] (-groupHeadings)               \033[0m";}
 M19(){ TPUT 21 3; $e "То же, что и -g, но вывести имя группы для каждого тега                    \033[32m -G[NUM][:NUM...] (-groupNames)                  \033[0m";}
 M20(){ TPUT 22 3; $e "Используйте форматирование таблицы HTML для вывода                         \033[32m -h (-htmlFormat)                                \033[0m";}
 M21(){ TPUT 23 3; $e "Показывать идентификационный номер тега в шестнадцатеричном формате        \033[32m -H (-hex)                                       \033[0m";}
 M22(){ TPUT 24 3; $e "Создайте динамическую веб-страницу, содержащую шестнадцатеричный дамп EXIF \033[32m -htmlDump[OFFSET]                               \033[0m";}
 M23(){ TPUT 25 3; $e "Используйте форматирование JSON                                            \033[32m -j[[+]=JSONFILE] (-json)                        \033[0m";}
 M24(){ TPUT 26 3; $e "Используйте длинный двухстрочный выходной формат в стиле Canon             \033[32m -l (-long)                                      \033[0m";}
 M25(){ TPUT 27 3; $e "Установите текущий язык для описаний тегов и преобразованных значений      \033[32m -lang [LANG]                                    \033[0m";}
 M26(){ TPUT 28 3; $e "Для тегов типа списка это приводит к извлечению элемента с индексом        \033[32m -listItem INDEX                                 \033[0m";}
 M27(){ TPUT 29 3; $e "Отключите преобразование печати для всех тегов                             \033[32m -n (--printConv)                                \033[0m";}
 M28(){ TPUT 30 3; $e "Вывод на печать в формате, заданном данным файлом или строкой              \033[32m -p FMTFILE or STR (-printFormat)                \033[0m";}
 M29(){ TPUT 31 3; $e "Отформатируйте вывод как массив PHP                                        \033[32m -php                                            \033[0m";}
 M30(){ TPUT 32 3; $e "Короткий выходной формат                                                   \033[32m -s[NUM] (-short)                                \033[0m";}
 M31(){ TPUT 33 3; $e "Очень короткий формат                                                      \033[32m -S (-veryShort)                                 \033[0m";}
 M32(){ TPUT 34 3; $e "Укажите разделительную строку для элементов в тегах типа списка            \033[32m -sep STR (-separator)                           \033[0m";}
 M33(){ TPUT 35 3; $e "Сортировать вывод по описанию тега или по имени тега                       \033[32m -sort, --sort                                   \033[0m";}
 M34(){ TPUT 36 3; $e "Вывод структурированной информации XMP вместо объединения в отдельные теги \033[32m -struct, --struct                               \033[0m";}
 M35(){ TPUT 37 3; $e "Вывести список описаний / значений, разделенных табуляцией                 \033[32m -t (-tab)                                       \033[0m";}
 M36(){ TPUT 38 3; $e "Вывести значения тегов в виде таблицы. Эквивалентно -t -S -q -f            \033[32m -T (-table)                                     \033[0m";}
#
 M37(){ TPUT 40 3; $e "Далее                                                                      \033[32m Onward                                          \033[0m";}
 M38(){ TPUT 41 3; $e "Выход                                                                      \033[32m EXIT                                            \033[0m";}
LM=38
   MENU(){ for each in $(seq 0 $LM);do M${each};done;}
    POS(){ if [[ $cur == up ]];then ((i--));fi
           if [[ $cur == dn ]];then ((i++));fi
           if [[ $i -lt 0   ]];then i=$LM;fi
           if [[ $i -gt $LM ]];then i=0;fi;}
REFRESH(){ after=$((i+1)); before=$((i-1))
           if [[ $before -lt 0  ]];then before=$LM;fi
           if [[ $after -gt $LM ]];then after=0;fi
           if [[ $j -lt $i      ]];then UNMARK;M$before;else UNMARK;M$after;fi
           if [[ $after -eq 0 ]] || [ $before -eq $LM ];then
           UNMARK; M$before; M$after;fi;j=$i;UNMARK;M$before;M$after;}
   INIT(){ R;HEAD;FOOT;MENU;}
     SC(){ REFRESH;MARK;$S;$b;cur=`ARROW`;}
# Функция возвращения в меню
     ES(){ MARK;$e " ENTER = main menu ";$b;read;INIT;};INIT
  while [[ "$O" != " " ]]; do case $i in
 0) S=M0;SC;if [[ $cur == enter ]];then R;echo "   Извлечь информацию для указанного тега (например, «-CreateDate»). В одной команде можно указать несколько тегов. Имя тега - это дескриптор, с помощью которого дана
 ссылка на часть информации. См. В Image :: ExifTool :: TagNames документацию по доступным именам тегов. Имя тега может включать ведущую группу имена, разделенные
 двоеточиями (например, «-EXIF: CreateDate» или «-Doc1: XMP: Creator»), и каждое имя группы может быть предварено цифрой, чтобы указать номер семейства (например,
 «-1IPTC: Город»). Используйте параметр -listg, чтобы перечислить доступные имена групп по семействам.
   Специальное имя тега «Все» может использоваться для обозначения всей метаинформации (т. Е. -Все). Это особенно полезно, когда имя группы указано для извлекать всю
 информацию в группе (но имейте в виду, что, если также не используется опция -a, некоторые теги в группе могут быть подавлены тегами с тем же именем в другие
 группы). Подстановочные знаки \"?\" и «*» могут использоваться в имени тега для соответствия любому одиночному символу и нулю или более символам соответственно.
 Их нельзя использовать в имени группы, за исключением того, что имя группы «*» (или «Все») может использоваться для извлечения всех экземпляров тега (как если бы -a
 было использовано). Обратите внимание, что аргументы, содержащие подстановочные знаки, должны быть заключены в кавычки в командной строке большинства систем, чтобы
 предотвратить подстановку команд оболочки.
   К имени тега можно добавить \"#\", чтобы отключить преобразование печати для каждого тега (см. Параметр -n). Это также можно использовать при написании или
 копирование тегов. Если теги не указаны, извлекается вся доступная информация (как если бы было указано «-All»).
   Примечание. При извлечении информации по умолчанию отображаются описания, а не имена тегов. Вместо этого используйте параметр -s, чтобы увидеть имена тегов.";ES;fi;;
 1) S=M1;SC;if [[ $cur == enter ]];then R;echo "   Исключить указанный тег из извлеченной информации. То же, что и опция -x. Имена групп и подстановочные знаки разрешены, как описано выше для -TAG. Один раз
 исключенный из вывода, тег не может быть повторно включен с помощью последующей опции. Также может использоваться после параметра -tagsFromFile для исключения тегов
 из копируемые (при перенаправлении на другой тег следует исключить именно исходный тег) или исключить группы из удаляемых при удалении вся информация (например,
 «-all = --exif: all» удаляет всю информацию, кроме EXIF). Но учтите, что это не исключает отдельные теги из группового удаления (если не указана группа «семья 2»,
 см. примечание 4 ниже). Вместо этого отдельные теги можно восстановить с помощью параметра -tagsFromFile (например, \"-all = -tagsfromfile @ -artist \").";ES;fi;;
 2) S=M2;SC;if [[ $cur == enter ]];then R;echo "   Напишите новое значение для указанного тега (например, «-comment = wow») или удалите тег, если ЗНАЧЕНИЕ не указано (например, «-comment =»). \"+ =\" и \"- =\"
 используются для добавления либо удалить существующие записи из списка, либо сдвинуть значения даты / времени (см. Image :: ExifTool :: Shift.pl и примечание 6 ниже
 для более подробной информации). \"+ =\" может также использоваться для увеличения числовых значений (или уменьшения, если VALUE отрицательное), а \"- =\" может
 использоваться для условного удаления или замены тега (см.WRITING ПРИМЕРЫ для примеров).\" ^ = \" Используется для записи пустой строки вместо удаления тега, когда
 не задано ЗНАЧЕНИЕ, но в остальном это эквивалентно знак равно.
   TAG может содержать одно или несколько ведущих имен групп семейств 0, 1, 2 или 7 с префиксом необязательных номеров семейств и разделенных двоеточиями. Если имя
 группы не указано, тег создается в предпочтительной группе и обновляется в любом другом месте, где уже существует тег с таким же именем. Предпочтительная группа
 первая группа в следующем списке, где действителен TAG: 1) EXIF, 2) IPTC, 3) XMP.
   Подстановочные знаки «*» и «?» может использоваться в именах тегов для присвоения одного и того же значения нескольким тегам. При указании с использованием
 подстановочных знаков \"небезопасные\" теги не являются написано. Имя тега «Все» эквивалентно «*» (за исключением того, что оно не требует заключения в кавычки, в
 то время как аргументы с подстановочными знаками требуются в системах с оболочкой globbing) и часто используется при удалении всех метаданных (например, «-All =»)
 или всей группы (например, «-XMP-dc: All =», см. примечание 4 ниже). Обратите внимание, что не все группы можно удалить, и что группа JPEG APP14 «Adobe» не удаляется
 по умолчанию с помощью «-All =», поскольку это может повлиять на внешний вид изображения.
   Однако информация о цветовом пространстве удаляется, поэтому цвета могут быть затронуты (но этого можно избежать, скопировав обратно теги, определенные
 ColorSpaceTags ярлык). Используйте параметр -listd для получения полного списка удаляемых групп и см. Примечание 5 ниже относительно групп «APP». Также, в
 изображении некоторые группы могут содержаться в других, и эти группы удаляются, если удаляется содержащая группа:
   Изображение JPEG:
   - Удаление EXIF или IFD0 также удаляет ExifIFD, GlobParamIFD, GPS, IFD1, InteropIFD, MakerNotes, PrintIM и SubIFD.
   - Удаление ExifIFD также удаляет InteropIFD и MakerNotes.
   - При удалении Photoshop также удаляется IPTC.
   Изображение TIFF:
   - Удаление EXIF удаляет только ExifIFD, который также удаляет InteropIFD и MakerNotes.";ES;fi;;
 3) S=M3;SC;if [[ $cur == enter ]];then R;echo " 1) В одной команде может быть присвоено множество значений тегов. Если два назначения влияют на один и тот же тег, последний имеет приоритет (за исключением типа
 списка теги, для которых записаны оба значения).
 2) Как правило, теги MakerNotes считаются «постоянными» и могут редактироваться, но не могут быть созданы или удалены по отдельности. Это позволяет избежать многих
 потенциальных проблемы, включая неизбежные проблемы совместимости с программным обеспечением OEM, которое может быть очень негибким в отношении информации, которую
 он ожидает найти в производитель отмечает.
 3) Изменения файлов PDF с помощью ExifTool обратимы (путем удаления обновления с помощью -PDF-update: all =), поскольку исходная информация никогда не является
 удален из файла. Таким образом, только ExifTool нельзя использовать для безопасного редактирования метаданных в файлах PDF.
 4) Указание «-GROUP: all =» удаляет всю группу как блок, только если указано одно семейство 0 или 1 группа. В противном случае все удаляемые теги в указанные группы
 удаляются индивидуально, и в этом случае можно исключить отдельные теги из массового удаления. Например, «-time: all --Exif: Time: All» удаляет все удаляемые теги
 времени, кроме тех, что находятся в EXIF. Это различие также применяется, если семейство 2 указано, когда удаление всех групп. Например, «-2all: all =» удаляет теги
 по отдельности, а «-all: all =» удаляет целые блоки.
 5) Имена групп «APP» (от «APP0» до «APP15») используются для удаления сегментов приложения JPEG, которые не связаны с другой удаляемой группой.
 Например, указание «-APP14: All =» НЕ удалит сегмент «Adobe» APP14, потому что это выполняется с помощью «-Adobe: All».
 6) При сдвиге значения сдвиг применяется к исходному значению тега, отменяя любые другие значения, ранее присвоенные тегу на та же командная строка. Чтобы сдвинуть
 значение даты / времени и скопировать его в другой тег в той же операции, используйте параметр -globalTimeShift.
 Особенность: Целочисленные значения могут быть указаны в шестнадцатеричном формате с начальным «0x», а простые рациональные значения могут быть указаны как дроби.";ES;fi;;
 4) S=M4;SC;if [[ $cur == enter ]];then R;echo "   Установите значение тега из содержимого файла DATFILE. Имя файла также может быть задано строкой FMT, где% d,% f и% e представляют каталог, имя файла и расширение
 исходного ФАЙЛА (подробнее см. параметр -w). Обратите внимание, что этот аргумент требуется в кавычках предотвратить перенаправление оболочки, так как она содержит
 символ «<». Если DATFILE / FMT не указан, эффект будет таким же, как и -TAG = и тег будет просто удалено. «+ <=» или «- <=» также могут использоваться для добавления
 или удаления определенных записей списка или для сдвига значений даты / времени.";ES;fi;;
 5) S=M5;SC;if [[ $cur == enter ]];then R;echo "
    Скопируйте значения тегов из SRCFILE в FILE. Имена тегов в командной строке после этой опции указывают теги, которые нужно скопировать или исключить из копии.
 В именах этих тегов разрешены подстановочные знаки. Если теги не указаны, то все возможные теги (см. Примечание 1 ниже) из исходного файла копируются в одноименные
 теги в предпочтительном месте выходного файла (то же самое, что и при указании «-all»). Для копирования можно использовать более одной опции -tagsFromFile теги из
 нескольких файлов.
    По умолчанию этот параметр обновит все существующие и доступные для записи теги с тем же именем в выходном ФАЙЛЕ, но создаст новые теги только в их
 предпочтительных группы. Это позволяет автоматически передавать некоторую информацию в соответствующую группу при копировании между изображениями разных форматов.
 Однако, если для тега указано имя группы, информация записывается только в эту группу (если не перенаправляется в другую группу, см. Ниже). Если в качестве имени
 группы используется \"All\", то указанные теги записываются в ту же группу семейства 1, что и в исходном файле (т. Е. Те же конкретные расположение, например
 ExifIFD или XMP-dc). Например, обычная операция копирования всех доступных для записи тегов в одни и те же конкретные места в выходном ФАЙЛЕ достигается добавлением
 «-all: all». Другое семейство может быть указано путем добавления ведущего номера семейства к имени группы (например, \"-0all: all\" сохраняет такое же общее
 расположение, как EXIF ​​или XMP).
    SRCFILE может быть тем же, что и FILE для перемещения информации внутри одного файла. В этом случае \"@\" может использоваться для представления исходного файла
 (т. Е. \"-tagsFromFile @\"), что позволяет использовать эту функцию для пакетной обработки нескольких файлов. Указанные теги затем копируются из каждого файла по
 очереди как он переписан. Для расширенного пакетного использования имя исходного файла также может быть указано с помощью строки FMT, в которой% d,% f и% e
 представляют каталог, имя файла и расширение FILE. (например, текущий ФАЙЛ будет представлен как «% d% f.% e» с тем же эффектом, что и «@»). См. Параметр -w для
 примеров строк FMT.
    Мощная функция перенаправления позволяет указывать тег назначения для каждого скопированного тега. С помощью этой функции информация может быть записана в тег
 с другим именем или группой. Это делается с помощью \"'-DSTTAG <SRCTAG'\" или \"'-SRCTAG> DSTTAG'\" в командной строке после -tagsFromFile и вызывает значение
 SRCTAG, которое будет скопировано из SRCFILE и записано в DSTTAG в FILE. Не действует, если SRCTAG не существует в SRCFILE. Обратите внимание, что этот аргумент
 должен заключаться в кавычки, чтобы предотвратить перенаправление оболочки, и отсутствует знак \"=\", как при присвоении новых значений. Теги источника и / или
 назначения могут иметь префикс название группы и / или с суффиксом \"#\". Подстановочные знаки разрешены в именах как исходных, так и целевых тегов. Группа
 назначения и / или имя тега \"All\" или \"*\" записывается в ту же группу и / или имя тега семейства 1, что и источник. Если группа назначения не указана, информация
 записывается в предпочтительная группа. Пробелы вокруг \">\" или \"<\" игнорируются. Для удобства предполагается, что для любых перенаправляемых тегов, которые
 являются указан без предшествующей опции -tagsFromFile. Скопированные теги также могут быть добавлены или удалены из списка с аргументами вида \"'-SRCTAG + <DSTTAG'\"
 или \"'-SRCTAG- <DSTTAG'\" (но см. Примечание 5 ниже).
   Расширение функции перенаправления позволяет использовать строки, содержащие имена тегов, с правой стороны символа «<» с синтаксисом «'-DSTTAG <STR'», где имена
 тегов в STR начинаются с символа «$». См. Параметр -p и раздел «Расширенное форматирование» для получения дополнительной информации подробности об этом синтаксисе.
 Строки, начинающиеся со знака «=», должны содержать один пробел после «<», чтобы избежать путаницы с оператором «<=», который устанавливает значение тега из
 содержимого файла. Один пробел в начале строки удаляется, если он существует, но все остальные пробелы в строка сохраняется. См. Примечание 8 ниже об использовании
 функции перенаправления с тегами типа списка, ярлыками или при использовании подстановочных знаков в именах тегов.
   См. «КОПИРОВАНИЕ ПРИМЕРОВ» для примеров использования -tagsFromFile.
";ES;fi;;
 6) S=M6;SC;if [[ $cur == enter ]];then R;echo "    1) Некоторые теги (обычно теги, которые могут влиять на внешний вид изображения) считаются небезопасными для записи и копируются только в том случае, если они
 указаны явно (т. е. без подстановочных знаков). Дополнительную информацию о «небезопасных» тегах см. В документации по именам тегов.
    2) Помните о разнице между исключением тега из копирования (--TAG) и удалением тега (-TAG =). Исключение тега предотвращает его копируется в целевое изображение,
 но при удалении из изображения удаляется уже существующий тег.
    3) Информация о создателе копируется как блок, поэтому последующие присвоения тегов в командной строке не влияют на нее, как на другую информацию, и отдельные
 теги makernote не могут быть исключены из блочной копии. Кроме того, поскольку PreviewImage, на который есть ссылка в заметках создателя, может быть довольно
 большим, он не копируется и при желании должен быть передан отдельно.
    4) Порядок операций - скопировать все указанные теги в точку параметра -tagsFromFile в командной строке. Любое присвоение тега справа от опции -tagsFromFile
 ставится после копирования всех тегов. Например, новые значения тегов устанавливаются в порядке «Один», «Два», «Три», затем «Четыре» с эта команда:
 exiftool -One = 1 -tagsFromFile s.jpg -Two -Four = 4 -Three d.jpg Это важно в том случае, когда существует перекрытие между скопированными и назначенными тегами,
 потому что более поздние операции могут переопределить более ранние.
    5) Нормальное поведение скопированных тегов отличается от поведения назначенных тегов для тегов типа списка и условных замен, поскольку каждая операция копирования
 на теге отменяет любые предыдущие операции. Хотя это позволяет избежать дублирования элементов списка при копировании групп тегов из файла, содержащего избыточные
 информации, он также предотвращает копирование значений разных тегов в один и тот же список, когда это является намерением. Итак, параметр -addTagsFromFile - это
 при условии, что позволяет копировать несколько тегов в один и тот же список. например) exiftool -addtagsfromfile @ '-subject <make' '-subject <model' ...
 Точно так же -addTagsFromFile необходимо использовать при условной замене тега, чтобы предотвратить переопределение более ранних условий.
 Помимо этих различий, параметры -tagsFromFile и -addTagsFromFile эквивалентны.
    6) Параметр -a (разрешить дублирование тегов) всегда действует при копировании тегов из SRCFILE, но тег с наивысшим приоритетом всегда копируется последним,
 поэтому он имеет приоритет.
    7) Структурированные теги по умолчанию копируются при копировании тегов. Подробнее см. Параметр -struct.
    8) При использовании функции перенаправления прямое копирование тега (т. Е. «'-DSTTAG <SRCTAG'») не то же самое, что интерполяция его значения внутри строки
 (т. Е. '-DSTTAG <$ SRCTAG') для тегов типа списка, ярлыков, имен тегов, содержащих подстановочные знаки, или переменных UserParam. При прямом копировании значения
 каждый соответствующий исходный тег копируется отдельно в целевой тег (как если бы они были отдельными назначениями). Однако при интерполяции внутри строка,
 элементы списка и значения ярлыков объединяются (с разделителем, установленным параметром -sep), а использование подстановочных знаков не допускается. Также,
 Переменные UserParam доступны только при интерполяции в строку. Другое отличие состоит в том, что если тег не существует, выдается небольшое предупреждение  при
 интерполяции его значения в строку (с «\$»), но не при прямом копировании тега.
    Наконец, поведение отличается при использовании тега назначения или группы «Все». При копировании напрямую группа назначения и / или имя тега «Все» записывается
 в ту же группу и / или имя тега семейства 1, что и источник. Но при интерполяции в строку идентичность исходных тегов теряется и значение записывается во все
 возможные группы / теги. Например, строковая форма должна использоваться в следующей команде, поскольку цель состоит в том, чтобы установить значение всех
 существующих тегов даты / времени из CreateDate: exiftool \"-time:all<$createdate\" -wm w FILE";ES;fi;;
 7) S=M7;SC;if [[ $cur == enter ]];then R;echo "    Исключить указанный тег. Может быть несколько параметров -x. Это имеет тот же эффект, что и --TAG в командной строке. См. Документацию --TAG выше для полного
 описания. Форматирование текста ввода-вывода. Обратите внимание, что конечные пробелы удаляются из извлеченных значений для большинства выходных текстовых форматов.
 Исключения составляют «-b», «-csv», «-j» и «-X».";ES;fi;;
 8) S=M8;SC;if [[ $cur == enter ]];then R;echo "    Вывести информацию в виде аргументов exiftool, подходящих для использования с опцией - @ при записи. Можно комбинировать с опцией -G для включения названия групп.
 Эта функция может использоваться для эффективного копирования тегов между изображениями, но позволяет изменять метаданные путем редактирования промежуточного файла.
 (out.args в этом примере): exiftool -args -G1 --filename --directory src.jpg> out.args
                            exiftool - @ out.args -sep "," dst.jpg
    Примечание: будьте осторожны при копировании информации с помощью этого метода, так как легко писать теги, которые обычно считаются «небезопасными». Например,
 теги FileName и Directory исключены в приведенном выше примере, чтобы избежать переименования и перемещения файла назначения. Также обратите внимание, что второй
 приведенная выше команда будет выдавать предупреждающие сообщения для любых тегов, которые недоступны для записи.
    Кроме того, следует использовать параметр -sep, как и во второй команде выше, чтобы поддерживать отдельные элементы списка при записи метаданных обратно в файлы
 изображений, и параметр -struct может использоваться при извлечении для сохранения структурированной информации XMP.";ES;fi;;
 9) S=M9;SC;if [[ $cur == enter ]];then R;echo "    Вывести запрошенные метаданные в двоичном формате без имен и описаний тегов. Этот параметр в основном используется для извлечения встроенных изображений или других
 двоичные данные, но это также может быть полезно для некоторых текстовых строк, поскольку управляющие символы (например, новые строки) не заменяются на '.' как они в
 вывод по умолчанию. По умолчанию элементы списка разделяются новой строкой при извлечении с помощью параметра -b, но это можно изменить (см. Параметр -sep для
 Детали). Можно комбинировать с «-j», «-php» или «-X» для извлечения двоичных данных в формате JSON, PHP или XML, но обратите внимание, что необходимо указать
 «небезопасные» теги явно быть извлеченным как двоичный файл в этих форматах.";ES;fi;;
10) S=M10;SC;if [[ $cur == enter ]];then R;echo "
    Установите формат печати для координат GPS. FMT использует тот же синтаксис, что и строка формата printf. Спецификаторы соответствуют градусам, минутам и секунд
 в таком порядке, но минуты и секунды указывать необязательно. Например, в следующей таблице приведены выходные данные для одной и той же координаты с использованием
 различных форматы:
         FMT                  Output
 -------------------   ------------------
 \"%d deg %d' %.2f\"\\     54 deg 59' 22.80\" (по умолчанию для чтения)
 \"%d %d %.8f\"           54 59 22.80000000 (по умолчанию для копирования)
 \"%d deg %.4f min\"      54 deg 59.3800 min
 \"%.6f degrees\"         54.989667 degrees

 Примечания:
 1) Чтобы избежать потери точности, формат координат по умолчанию отличается при копировании тегов с помощью параметра -tagsFromFile.
 2) Если полушарие известно, опорное направление (N, S, E или W) добавляется к каждой напечатанной координате, но с добавлением \"+\" к спецификатору формата.
    (например, "% +. 6f") вместо этого печатает координату со знаком.
 3) Это форматирование печати можно отключить с помощью опции -n для извлечения координат в виде десятичных градусов со знаком.
";ES;fi;;
11) S=M11;SC;if [[ $cur == enter ]];then R;echo "
    Если TYPE - «ExifTool» или не указан, этот параметр устанавливает кодировку символов ExifTool для значений тегов вывода при чтении и значений ввода, когда запись
 со значением по умолчанию UTF8. Если CHARSET не указан, возвращается список доступных наборов символов. Допустимые значения CHARSET:
                CHARSET     Alias(es)        Description
                ----------  ---------------  ----------------------------------
                UTF8        cp65001, UTF-8   UTF-8 characters (default)
                Latin       cp1252, Latin1   Windows Latin1 (West European)
                Latin2      cp1250           Windows Latin2 (Central European)
                Cyrillic    cp1251, Russian  Windows Cyrillic
                Greek       cp1253           Windows Greek
                Turkish     cp1254           Windows Turkish
                Hebrew      cp1255           Windows Hebrew
                Arabic      cp1256           Windows Arabic
                Baltic      cp1257           Windows Baltic
                Vietnam     cp1258           Windows Vietnamese
                Thai        cp874            Windows Thai
                DOSLatinUS  cp437            DOS Latin US
                DOSLatin1   cp850            DOS Latin1
                DOSCyrillic cp866            DOS Cyrillic
                MacRoman    cp10000, Roman   Macintosh Roman
                MacLatin2   cp10029          Macintosh Latin2 (Central Europe)
                MacCyrillic cp10007          Macintosh Cyrillic
                MacGreek    cp10006          Macintosh Greek
                MacTurkish  cp10081          Macintosh Turkish
                MacRomanian cp10010          Macintosh Romanian
                MacIceland  cp10079          Macintosh Icelandic
                MacCroatian cp10082          Macintosh Croatian
   TYPE может быть «FileName», чтобы указать кодировку имен файлов в командной строке (т. Е. Аргументы FILE). В Windows это вызывает использование широкого
 подпрограммы ввода-вывода символов, таким образом обеспечивая поддержку имен файлов Unicode. Подробности см. В разделе «ИМЕНА ФАЙЛОВ WINDOWS UNICODE» ниже.
 Другие значения TYPE, перечисленные ниже, используются для определения внутреннего кодирования различных форматов метаинформации.
";ES;fi;;
12) S=M12;SC;if [[ $cur == enter ]];then R;echo "  ТИП Описание По умолчанию
 ----------------------------------------------------------
 EXIF Внутренняя кодировка строк EXIF ​ASCII (нет)
 ID3 Внутренняя кодировка информации ID3v1 латиницей
 IPTC Внутренняя кодировка IPTC, которая предполагается при использовании латиницы.
 IPTC: CodedCharacterSet не определен
 Photoshop Внутренняя кодировка строк Photoshop IRB Latin
 QuickTime Внутренняя кодировка строк QuickTime MacRoman
 RIFF Внутреннее кодирование строк RIFF 0
    См. Https://exiftool.org/faq.html#Q10 для получения дополнительной информации о наборах кодированных символов и параметры Image :: ExifTool для получения
 дополнительных сведений о -charset настройки.";ES;fi;;
13) S=M13;SC;if [[ $cur == enter ]];then R;echo "    Экспорт информации в формате CSV или импорт информации, если указан CSVFILE. При импорте файл CSV должен быть в том же формате, что и экспортированный файл.
 Первая строка CSVFILE должна содержать имена тегов ExifTool (с необязательными именами групп) для каждого столбца файла и значения должны быть разделены запятыми.
 В специальном столбце «Исходный файл» указываются файлы, связанные с каждой строкой информации (а исходный файл со знаком «*» может использоваться для определения
 тегов по умолчанию, которые будут импортированы для всех файлов, которые объединены с любыми тегами, указанными для конкретного обработанного исходного файла).
 В следующие примеры демонстрируют базовое использование этой опции:
 создать CSV-файл с общими тегами из всех изображений в каталоге:  exiftool -common -csv каталог> out.csv
 обновить метаданные для всех изображений в каталоге из файла CSV: exiftool -csv = a.csv каталог
    Пустые значения игнорируются при импорте (если не используется параметр -f и для API MissingTagValue задана пустая строка, и в этом случае тег удалено). Кроме
 того, столбцы FileName и Directory игнорируются, если они существуют (т. Е. ExifTool не будет пытаться записать эти теги при импорте CSV). К принудительно удалить
 тег, используйте параметр -f и установите значение «-» в файле CSV (или значение MissingTagValue, если использовалась эта опция API). За одну команду можно
 импортировать несколько баз данных.
    При экспорте файла CSV опция -g или -G добавляет имена групп к заголовкам тегов. Если параметр -a используется для разрешения дублирования имен тегов, параметр
 повторяющиеся теги включаются в вывод CSV только в том случае, если заголовки столбцов уникальны. Добавление опции -G4 обеспечивает уникальный заголовок столбца для
 каждого тег. Параметр -b может быть добавлен для вывода двоичных данных, закодированных в base64, если необходимо (обозначено ASCII «base64:» как первые 7 байтов
 ценность). Значения также могут быть закодированы в base64, если используется опция -charset и значение содержит недопустимые символы.
    При экспорте определенных тегов столбцы CSV располагаются в том же порядке, что и указанные теги, при условии, что заголовки столбцов точно соответствуют
 указанные имена тегов, в противном случае столбцы сортируются в алфавитном порядке. При импорте из файла CSV обрабатываются только файлы, указанные в командной
 строке. Любые лишние записи в файле CSV игнорируются. Теги типа списка хранятся в виде простых строк в файле CSV, но можно использовать параметр -sep, чтобы
 разбить их обратно на отдельные элементы при импорте. Специальная функция: -csv + = CSVFILE может использоваться для добавления элементов в существующие списки.
 Это влияет только на теги типа списка. Также относится к опции -j.
    Обратите внимание, что этот параметр принципиально отличается от всех других параметров выходного формата, поскольку он требует, чтобы информация из всех входных
 файлов была буферизуется в памяти перед записью вывода. Это может привести к чрезмерному использованию памяти при обработке очень большого количества файлов с
 помощью одного команда. Кроме того, это делает этот параметр несовместимым с параметром -w. При обработке большого количества файлов рекомендуется либо использовать
 Формат вывода JSON (-j) или XML (-X) или используйте -p для создания файла CSV с фиксированным столбцом вместо использования параметра -csv.";ES;fi;;
14) S=M14;SC;if [[ $cur == enter ]];then R;echo "    Установите формат значений тегов даты / времени. Строка FMT может содержать коды форматирования, начинающиеся с символа процента (\"%\") для представления
 различные компоненты значения даты / времени. Особенности синтаксиса FMT зависят от системы - обратитесь к странице руководства \"strftime\" в вашей системе, чтобы
 узнать Детали. Формат по умолчанию эквивалентен «% Y:% m:% d% H:% M:% S». Этот параметр не влияет на теги только даты или времени и игнорирует часовой пояс.
 информация, если таковая имеется. Для каждой команды можно использовать только одну опцию -d. Требуется POSIX :: strptime или Time :: Piece для преобразования
 инверсии, когда письмо.";ES;fi;;
15) S=M15;SC;if [[ $cur == enter ]];then R;echo " Показывать идентификационный номер тега в десятичном формате при извлечении информации.";ES;fi;;
16) S=M16;SC;if [[ $cur == enter ]];then R;echo "    Экранирующие символы в значениях выходных тегов для HTML (-E), XML (-ex) или C (-ec). Для HTML все символы с кодовыми точками Unicode выше U + 007F являются
 экранированы, а также следующие 5 символов: & (& amp;) '(& # 39;) \"(& quot;)> (& gt;) и <(& lt;). Для XML экранируются только эти 5 символов. Параметр -E
 подразумевается с -h, а -ex подразумевается с -X. Для C все управляющие символы и обратная косая черта экранируются. Обратное преобразование применяется при
 написании тегов.";ES;fi;;
17) S=M17;SC;if [[ $cur == enter ]];then R;echo "    Принудительная печать тегов, даже если их значения не найдены. Этот параметр применяется только тогда, когда в командной строке запрашиваются определенные теги
 (т. Е. Не с подстановочными знаками или -all). При использовании этой опции тире (-) печатается для значения любого отсутствующего тега, но тире можно изменить через
 API. Параметр MissingTagValue. Также может использоваться для добавления атрибута flags в вывод -listx или для разрешения удаления тегов при записи с помощью
 -csv = функция CSVFILE.";ES;fi;;
18) S=M18;SC;if [[ $cur == enter ]];then R;echo "    Организуйте вывод по группам тегов. NUM указывает номер семейства группы и может быть 0 (общее расположение), 1 (конкретное расположение), 2 (категория),
 3 (документ номер), 4 (номер экземпляра), 5 (путь к метаданным), 6 (формат EXIF / TIFF) или 7 (идентификатор тега). -g0 предполагается, если номер семейства не
 указан. Может быть в сочетании с другими параметрами для добавления имен групп к выходным данным. Можно указать несколько семейств, разделив их двоеточием.
 По умолчанию итоговое имя группы упрощается за счет удаления любого ведущего «Main:» и сворачивания смежных идентичных имен групп, но этого можно избежать,
 поместив двоеточие перед первым номером семьи (например, -g: 3: 1). Используйте параметр -listg, чтобы вывести список имен групп для указанного семейства.
 API SavePath и SaveFormat параметры включаются автоматически, если запрашиваются соответствующие имена групп семейств 5 или 6. Дополнительную информацию см.
 В документации API GetGroup.";ES;fi;;
19) S=M19;SC;if [[ $cur == enter ]];then R;echo "    То же, что и -g, но вывести имя группы для каждого тега. -G0 предполагается, если ЧИСЛО не указано. Можно комбинировать с рядом других опций для добавления группы
 имена к выходу. Обратите внимание, что NUM можно добавить везде, где в документации упоминается -G. Подробнее см. Параметр -g выше.";ES;fi;;
20) S=M20;SC;if [[ $cur == enter ]];then R;echo "    Используйте форматирование таблицы HTML для вывода. Подразумевается опция -E. Параметры форматирования -D, -H, -g, -G, -l и -s могут использоваться в сочетании
 с -h для влияют на формат HTML.";ES;fi;;
21) S=M21;SC;if [[ $cur == enter ]];then R;echo " Показывать идентификационный номер тега в шестнадцатеричном формате при извлечении информации.";ES;fi;;
22) S=M22;SC;if [[ $cur == enter ]];then R;echo "    Создайте динамическую веб-страницу, содержащую шестнадцатеричный дамп информации EXIF. Это может быть очень мощным инструментом для низкоуровневого анализа EXIF.
 Информация. Параметр -htmlDump также вызывается, если параметры -v и -h используются вместе. Уровень подробности определяет максимальную длину блоки сброшены.
 СМЕЩЕНИЕ может быть задано для определения базы для отображаемых смещений. Если не указано, используется базовое смещение EXIF / TIFF. Используйте -htmlDump0 для
 абсолютных смещений. В настоящее время выгружается только информация EXIF / TIFF и JPEG, но можно использовать параметр -u для получения необработанного
 шестнадцатеричного дампа другого файла форматы.";ES;fi;;
23) S=M23;SC;if [[ $cur == enter ]];then R;echo "    Используйте форматирование JSON (нотация объектов JavaScript) для вывода на консоль или импортируйте файл JSON, если указан JSONFILE. Этот вариант можно
 комбинировать с -g, чтобы организовать вывод в объекты по группам, или -G, чтобы добавить имена групп к каждому тегу. Теги типа списка с несколькими элементами
 выводятся в виде массивов JSON если не используется -sep. По умолчанию структуры XMP объединяются в отдельные теги в выводе JSON, но исходная структура может быть
 сохранена с параметром -struct (это также приводит к тому, что все теги XMP типа списков выводятся в виде массивов JSON, в противном случае списки с одним элементом
 будут выводиться как простые струны). Параметр -a подразумевается, если используются параметры -g или -G, в противном случае он игнорируется и теги с идентичными
 именами JSON подавляются. (-g4 может использоваться, чтобы гарантировать, что все теги имеют уникальные имена JSON.) Добавление параметра -D или -H изменяет значения
 тегов на объекты JSON с \"val\" и \"id\" fields, а добавление -l добавляет поле «desc» и поле «num», если числовое значение отличается от преобразованного «val».
 Можно добавить параметр -b для вывода двоичных данных, закодированных в base64, если необходимо (обозначенных ASCII «base64:» как первые 7 байтов значения), и -t
 может быть добавлен для включения информация о таблице тегов (подробнее см. -t). Выходными данными JSON является UTF-8 независимо от настройки параметра -L или
 -charset, но проверка UTF-8 выполняется отключено, если указан набор символов, отличный от UTF-8.
    Если указан JSONFILE, файл импортируется, и определения тегов из файла используются для установки значений тегов для каждого файла. Специальный Запись
 «SourceFile» в каждом объекте JSON связывает информацию с конкретным целевым файлом. Объект с отсутствующим SourceFile или SourceFile из «*» определяет теги по
 умолчанию для всех целевых файлов, которые комбинируются с любыми тегами, указанными для конкретного обрабатываемого исходного файла. Импортированный JSON файл
 должен иметь тот же формат, что и экспортированные файлы JSON, за исключением того, что параметр -g несовместим с форматом файла импорта (используйте -G вместо).
 Кроме того, имена тегов во входном файле JSON могут иметь суффикс «#», чтобы отключить преобразование печати.
    В отличие от импорта CSV, пустые значения не игнорируются и приводят к записи пустого значения, если это поддерживается конкретным типом метаданных. Теги
 удаляется с помощью параметра -f и установки значения тега равным «-» (или параметру MissingTagValue, если использовался этот параметр API). Импорт с -j + = JSONFILE
 вызывает добавление новых значений в существующие списки.";ES;fi;;
24) S=M24;SC;if [[ $cur == enter ]];then R;echo "    Используйте длинный двухстрочный выходной формат в стиле Canon. Добавляет описание и непреобразованное значение (если оно отличается от преобразованного значения)
 в XML, JSON или Вывод PHP при использовании -X, -j или -php. Также можно комбинировать с -listf, -listr или -listwf для добавления описаний типов файлов.";ES;fi;;
25) S=M25;SC;if [[ $cur == enter ]];then R;echo "
    Установите текущий язык для описаний тегов и преобразованных значений. LANG - это «de», «fr», «ja» и т. Д. Используйте -lang без других аргументов, чтобы получить
 список доступные языки. Если -lang не указан, языком по умолчанию является «en». Обратите внимание, что имена тегов / групп всегда английские, независимо от -lang.
 настройка и перевод предупреждений / сообщений об ошибках еще не реализованы. Также можно комбинировать с -listx для вывода описаний в один только язык.
    По умолчанию ExifTool использует кодировку UTF-8 для специальных символов, но для вызова других кодировок можно использовать параметр -L или -charset. Обратите
 внимание, что ExifTool использует Unicode :: LineBreak, если он доступен, чтобы помочь сохранить выравнивание столбцов при выводе обычного текста для языков с
 переменной шириной набор символов.
    В настоящее время языковая поддержка не завершена, но пользователи могут помочь улучшить это, отправив свои собственные переводы. Чтобы представить перевода,
 выполните следующие действия (для этого у вас должен быть установлен Perl):
    1. Скачайте и распакуйте последний полный дистрибутив Image-ExifTool.
    2. «cd» в каталог Image-ExifTool.
    3. Выполните эту команду, чтобы создать XML-файл с нужными тегами (например, EXIF): ./exiftool -listx -exif:all > out.xml
    4. Скопируйте этот текст в файл с именем import.pl в каталоге exiftool:
                push @INC, 'lib';
                require Image::ExifTool::TagInfoXML;
                my $file = shift or die "Expected XML file name\n";
                $Image::ExifTool::TagInfoXML::makeMissing = shift;
                Image::ExifTool::TagInfoXML::BuildLangModules($file,8);
    5. Запустите сценарий import.pl, чтобы импортировать XML-файл, создав записи «ОТСУТСТВУЮЩИЕ» для вашего языка (например, русского): perl import.pl out.xml ru
    6. Отредактируйте созданный языковой модуль lib/Image/ExifTool/Lang/ru.pm найдите и замените все строки «MISSING» в файле вашими переводами.
    7. Отправьте модуль (в данном примере ru.pm) по электронной почте на адрес: philharvey66 at gmail.com
    8. Спасибо !!
";ES;fi;;
26) S=M26;SC;if [[ $cur == enter ]];then R;echo "    Для тегов типа списка это приводит к извлечению только элемента с указанным индексом. ИНДЕКС равен 0 для первого элемента в списке. Отрицательные показатели также
 может использоваться для ссылки на элементы из конца списка. Не влияет на однозначные теги. Также применяется к значениям тегов при копировании из тег и в условиях
 -if.";ES;fi;;
27) S=M27;SC;if [[ $cur == enter ]];then R;echo "
    Отключите преобразование печати для всех тегов. По умолчанию извлеченные значения конвертируются в более удобный для чтения формат, но опция -n отключает это
 преобразование, показывающее машиночитаемые значения. Например:
                > exiftool -Orientation -S a.jpg
                Orientation: Rotate 90 CW
                > exiftool -Orientation -S -n a.jpg
                Orientation: 6
    Преобразование печати также можно отключить для каждого тега, добавив к имени тега суффикс символа \"#\":
                > exiftool -Orientation# -Orientation -S a.jpg
                Orientation: 6
                Orientation: Rotate 90 CW
    Эти методы также могут использоваться для отключения обратного преобразования печати при записи. Например, все следующие команды имеют одинаковый эффект:
                > exiftool -Orientation='Rotate 90 CW' a.jpg
                > exiftool -Orientation=6 -n a.jpg
                > exiftool -Orientation#=6 a.jpg
";ES;fi;;
28) S=M28;SC;if [[ $cur == enter ]];then R;echo "
    Вывод на печать в формате, заданном данным файлом или строкой. Аргумент интерпретируется как строка, если не существует файла с таким именем, в котором если
 строка загружается из содержимого файла. Имена тегов в файле или строке формата начинаются с символа «\$» и могут содержать начальную группу имена и / или
 завершающий знак \"#\" (для отключения преобразования печати). Дело не имеет значения. Скобки \"{}\" могут использоваться вокруг имени тега, чтобы отделить его от
 последующий текст. Используйте \$\$ для обозначения символа «$» и $ / для новой строки.
    Можно использовать несколько параметров -p, каждая из которых выводит строку (или более) текста. Выводятся строки, начинающиеся с \"# [HEAD]\" и \"# [TAIL]\".
 перед первым обработанным файлом и после последнего обработанного файла соответственно. Строки, начинающиеся с \"# [SECT]\" и \"# [ENDS]\" выводятся перед и после
 каждого раздела файлов. Раздел определяется как группа последовательных файлов с одинаковым заголовком раздела (например, файлы группируются по каталогам, если
 \"# [SECT]\" содержит каталог \$). Строки, начинающиеся с «# [BODY]» и строки, не начинающиеся с «#», выводятся для каждого обработанного файла. Начало строк с
 \"# [IF]\" не выводятся, но все строки BODY пропускаются, если какой-либо тег в строке IF не существует. Остальные строки, начинающиеся с \"#\", игнорируются. За
 Например, этот файл формата:
                # this is a comment line
                #[HEAD]-- Generated by ExifTool $exifToolVersion --
                File: \$FileName - \$DateTimeOriginal
                (f/\$Aperture, \${ShutterSpeed}s, ISO \$EXIF:ISO)
                #[TAIL]-- end --
 с помощью этой команды:
                exiftool -p test.fmt a.jpg b.jpg
 производит такой вывод:
                -- Generated by ExifTool 12.05 --
                File: a.jpg - 2003:10:31 15:44:19
                (f/5.6, 1/60s, ISO 100)
                File: b.jpg - 2006:05:23 11:57:38
                (f/8.0, 1/13s, ISO 100)
                -- end --
   Значения тегов типа списка с несколькими элементами и тегов ярлыков, представляющих несколько тегов, объединяются в соответствии с настройкой параметра -sep, когда
 вставляется в строку. Когда -ee (-extractEmbedded) комбинируется с -p, внедренные документы эффективно обрабатываются как отдельные входные файлы. Если указанный
 тег не существует, выдается незначительное предупреждение и строка с отсутствующим тегом не печатается. Однако опцию -f можно использовать для установите значение
 отсутствующих тегов на '-' (но это можно настроить с помощью параметра API MissingTagValue), или параметр -m может использоваться для игнорирования второстепенных
 предупреждения и оставьте пропущенные значения пустыми. В качестве альтернативы можно использовать -q -q, чтобы просто подавить предупреждающие сообщения.
   «Функция расширенного форматирования» может использоваться для изменения значений отдельных тегов с параметром -p.
";ES;fi;;
29) S=M29;SC;if [[ $cur == enter ]];then R;echo "
    Отформатируйте вывод как массив PHP. Параметры -g, -G, -D, -H, -l, -sep и -struct комбинируются с -php, и повторяющиеся теги обрабатываются так же, как с
 параметром -json. Кроме того, параметр -b может быть добавлен для вывода двоичных данных, и -t может быть добавлен для включения информации таблицы тегов (см. -T для
 Детали). Вот простой пример, показывающий, как это можно использовать в сценарии PHP:
                <?php
                eval('$array=' . \`exiftool -php -q image.jpg\`);
                print_r($array);
                ?>
";ES;fi;;
30) S=M30;SC;if [[ $cur == enter ]];then R;echo "
    Короткий выходной формат. Печатает имена тегов вместо описаний. Добавьте NUM или до 3-х параметров для еще более коротких форматов:
                -s1 or -s        - print tag names instead of descriptions
                -s2 or -s -s     - no extra spaces to column-align values
                -s3 or -s -s -s  - print values only (no tag names)
    Также эффективен в сочетании с параметрами -t, -h, -X или -listx.
";ES;fi;;
31) S=M31;SC;if [[ $cur == enter ]];then R;echo "    Очень короткий формат. То же, что и опции -s2 или два -s. Имена тегов печатаются вместо описаний, и никакие лишние пробелы не добавляются для выравнивания по
 столбцам ценности.";ES;fi;;
32) S=M32;SC;if [[ $cur == enter ]];then R;echo "    Укажите разделительную строку для элементов в тегах типа списка. При чтении по умолчанию элементы списка объединяются с помощью \",\\ \". При записи эта опция
 вызывает значения, присвоенные тегам типа списка, которые должны быть разделены на отдельные элементы в каждой подстроке, соответствующей STR (в противном случае они
 не разделяются по умолчанию). Космос символы в STR соответствуют нулю или более пробелов в значении. Обратите внимание, что пустой разделитель (\"\") разрешен и
 будет соединять элементы без разделителя при чтении или разделять значение на отдельные символы, когда письмо.
    Для чисто двоичного вывода (-b используется без -j, -php или -X) первая опция -sep указывает разделитель элементов списка, а вторая опция -sep указывает
 терминатор в конце списка (или после каждого значения, если не список). В этих строках \"\\ n\", \"\\ r\" и \"\\ t\" могут использоваться для обозначения новой строки,
 возврат каретки и табуляция соответственно. По умолчанию элементы двоичного списка разделяются новой строкой, и терминатор не добавляется.";ES;fi;;
33) S=M33;SC;if [[ $cur == enter ]];then R;echo "    Сортировать вывод по описанию тега или по имени тега, если используется опция -s. При сортировке по описанию порядок сортировки будет зависеть от параметра -lang.
 параметр. Без опции -sort теги отображаются в том порядке, в котором они были указаны в командной строке, или, если не указан, в том порядке, в котором они были
 извлеченный из файла. По умолчанию теги организованы по группам при сочетании с параметром -g или -G, но эту группировку можно отключить с помощью --sort";ES;fi;;
34) S=M34;SC;if [[ $cur == enter ]];then R;echo "    Выводит структурированную информацию XMP вместо объединения в отдельные теги. Этот вариант хорошо работает в сочетании с XML (-X) и JSON (-j) форматы вывода. Для
 других форматов вывода структуры и списки XMP сериализуются в тот же формат, что и при записи структурированной информации (см. https://exiftool.org/struct.html для
 подробностей). При копировании структурированные теги копируются по умолчанию, если для отключения этой функции не используется --struct (хотя сглаженные теги все
 еще можно копировать, задав их индивидуально, если не используется -struct). Эти параметры не действуют при назначении новых значения, поскольку при записи всегда
 можно использовать как плоские, так и структурированные теги.";ES;fi;;
35) S=M35;SC;if [[ $cur == enter ]];then R;echo "    Вывести список описаний / значений, разделенных табуляцией (полезно при импорте базы данных). Можно комбинировать с -s для печати имен тегов вместо описаний, или
 -S для печати только значений тегов, разделенных табуляцией в одной строке. Опцию -t можно комбинировать с -j, -php или -X для добавления информации таблицы тегов.
 (\"table\", tag \"id\", and \"index\" для случаев, когда существует несколько условных тегов с одним и тем же идентификатором).";ES;fi;;
36) S=M36;SC;if [[ $cur == enter ]];then R;echo " Вывести значения тегов в виде таблицы. Эквивалентно -t -S -q -f. ";ES;fi;;
#
37) S=M37;SC;if [[ $cur == enter ]];then R;./mExiftoolTagB.sh;ES;fi;;
38) S=M38;SC;if [[ $cur == enter ]];then R;clear;exit 0;fi;;
 esac;POS;done
